äº†è§£ï¼Œä½ çš„ç¨‹å¼æ¶æ§‹å·²ç¶“å¾ˆä¸éŒ¯äº†ï¼Œæˆ‘å¹«ä½ æ•´ç†ã€Œå»ºè­°ä¿®æ”¹é‡é»ã€èˆ‡ã€Œä¿®æ­£ç¯„ä¾‹ã€ï¼Œæ–¹ä¾¿ä½ ä¸€æ­¥æ­¥ä¿®æ”¹å’Œé©—è­‰ã€‚

---

# ğŸ”§ ä½ è¦ä¿®çš„åœ°æ–¹åŠå»ºè­°ä¿®æ”¹

## 1. api/webhook.py

* è£œä¸Š `process_text_message()` å‡½å¼ï¼Œå¦å‰‡ webhook æ”¶åˆ°æ–‡å­—è¨Šæ¯æœƒå ±éŒ¯
* åœ–ç‰‡è™•ç†å»ºè­°æ”¹ç”¨ `process_image_with_text()` çµåˆæ–‡å­—èˆ‡åœ–ç‰‡åˆ†æï¼Œæˆ–æ“´å……åœ–ç‰‡åˆ†ææµç¨‹
* å›è¦†å‡½å¼åŠ ä¸ŠéŒ¯èª¤æª¢æŸ¥èˆ‡éåŒæ­¥ï¼ˆå¦‚æœä½ æƒ³å„ªåŒ–ï¼‰
* `reply_to_line` å»ºè­°åŠ å…¥éŒ¯èª¤è™•ç†å’Œlogæ–¹ä¾¿debug
* webhook å›å‚³å›ºå®š `'OK'` å¯ä»¥ä¿ç•™ï¼Œä½†éŒ¯èª¤æ™‚å¯å›å…¶ä»–ç‹€æ…‹ç¢¼
* `get_line_image` å¯åŠ å¤±æ•—é‡è©¦æˆ–log

## 2. src/gemini_responder.py

* å»ºè­°èª¿æ•´ `generate_response_with_image()` æ”¯æ´æ–‡å­—+åœ–ç‰‡çµåˆè¼¸å…¥
* `generate_response()` prompt å¯ä»¥å„ªåŒ–æ ¼å¼è·ŸåŠ å…¥ context åƒæ•¸
* ç›®å‰ä½ ç”¨çš„æ˜¯ `gemini-1.5-flash`ï¼Œå¦‚æœè¦ç”¨ `gemini-2.5-flash` æˆ–å¤šæ¨¡æ…‹ï¼Œè¨˜å¾—æ¨¡å‹è¦æ”¹å°

## 3. src/knowledge_retriever.py

* å»ºè­°åŠ å…¥æ›´å¤šé—œéµå­—èˆ‡æ›´è¤‡é›œæª¢ç´¢ï¼ˆä¾‹å¦‚ç”¨å‘é‡æœå°‹ï¼‰
* åŠ å…¥é è¨­å›æ‡‰æˆ–æ²’æ‰¾åˆ°çµæœçš„ fallback

---

# ğŸ›  ä¿®æ­£ç‰ˆç¤ºç¯„

---

## api/webhook.py

```python
from flask import Flask, request
import json
import requests
import os

from src.knowledge_retriever import KnowledgeRetriever
from src.gemini_responder import GeminiResponder

app = Flask(__name__)

CHANNEL_SECRET = os.getenv('LINE_CHANNEL_SECRET')
CHANNEL_ACCESS_TOKEN = os.getenv('LINE_CHANNEL_ACCESS_TOKEN')

retriever = KnowledgeRetriever()
responder = GeminiResponder(api_key=os.getenv('GEMINI_API_KEY'))


def process_text_message(user_message):
    knowledge = retriever.retrieve(user_message)
    combined_knowledge = "\n".join(knowledge) if knowledge else "ç„¡ç›¸é—œçŸ¥è­˜"
    ai_reply = responder.generate_response(user_message, combined_knowledge)
    return ai_reply


def process_image_message(image_bytes):
    return responder.generate_response_with_image(image_bytes)


def process_image_with_text(image_bytes, user_message):
    knowledge = retriever.retrieve(user_message)
    combined_knowledge = "\n".join(knowledge) if knowledge else ""
    prompt = f"""
ä½¿ç”¨è€…ä¸Šå‚³äº†ä¸€å¼µå ±ä¿®åœ–ç‰‡ï¼Œä¸¦æè¿°å•é¡Œå¦‚ä¸‹ï¼š
ã€Œ{user_message}ã€

è«‹çµåˆåœ–ç‰‡èˆ‡æè¿°å…§å®¹ï¼Œåˆ†æå¯èƒ½å•é¡Œèˆ‡å»ºè­°ã€‚
"""
    response = responder.model.generate_content([prompt, image_bytes])
    return response.text


@app.route("/api/webhook", methods=['POST'])
def webhook():
    try:
        body = request.get_data(as_text=True)
        events = json.loads(body).get('events', [])

        if len(events) == 0:
            return 'OK'

        for event in events:
            if event['type'] == 'message':
                msg_type = event['message']['type']
                reply_token = event['replyToken']
                user_id = event['source']['userId']

                if msg_type == 'text':
                    user_message = event['message']['text']
                    response = process_text_message(user_message)
                    reply_to_line(reply_token, response)

                elif msg_type == 'image':
                    message_id = event['message']['id']
                    image_bytes = get_line_image(message_id)
                    # é€™é‚Šå…ˆç”¨ç°¡å–®åœ–ç‰‡å›æ‡‰ï¼Œä¹Ÿå¯ä»¥æ”¹ç”¨æ–‡å­—çµåˆåœ–ç‰‡ï¼š
                    response = process_image_message(image_bytes)
                    reply_to_line(reply_token, response)

                else:
                    reply_to_line(reply_token, "æŠ±æ­‰ï¼Œç›®å‰åªæ”¯æ´æ–‡å­—èˆ‡åœ–ç‰‡è¨Šæ¯ã€‚")

        return 'OK'
    except Exception as e:
        print("Webhook éŒ¯èª¤:", e)
        return 'Error', 500


def get_line_image(message_id):
    url = f"https://api-data.line.me/v2/bot/message/{message_id}/content"
    headers = {'Authorization': f'Bearer {CHANNEL_ACCESS_TOKEN}'}
    res = requests.get(url, headers=headers)
    if res.status_code != 200:
        print(f"ä¸‹è¼‰åœ–ç‰‡å¤±æ•—ï¼Œç‹€æ…‹ç¢¼ï¼š{res.status_code}")
        return None
    return res.content


def reply_to_line(reply_token, text):
    url = 'https://api.line.me/v2/bot/message/reply'
    headers = {
        'Content-Type': 'application/json',
        'Authorization': f'Bearer {CHANNEL_ACCESS_TOKEN}'
    }
    data = {
        'replyToken': reply_token,
        'messages': [{'type': 'text', 'text': text}]
    }
    resp = requests.post(url, headers=headers, json=data)
    if resp.status_code != 200:
        print(f"å›è¦†è¨Šæ¯å¤±æ•—: {resp.status_code} {resp.text}")
```

---

## src/gemini_responder.py

```python
import google.generativeai as genai

class GeminiResponder:
    def __init__(self, api_key):
        genai.configure(api_key=api_key)
        self.model = genai.GenerativeModel('gemini-2.5-flash')  # æ”¹ç”¨å¤šæ¨¡æ…‹æ–°ç‰ˆ

    def generate_response(self, query, knowledge):
        prompt = f"""
ä½ æ˜¯æ™ºæ…§å ±ä¿®åŠ©ç†ï¼Œæ ¹æ“šä»¥ä¸‹çŸ¥è­˜èˆ‡ä½¿ç”¨è€…å•é¡Œçµ¦å‡ºç°¡æ½”å»ºè­°ã€‚

çŸ¥è­˜ï¼š
{knowledge}

å•é¡Œï¼š
{query}
"""
        response = self.model.generate_content(prompt)
        return response.text

    def generate_response_with_image(self, image_bytes):
        prompt = "é€™æ˜¯ç”¨æˆ¶ä¸Šå‚³çš„å ±ä¿®åœ–ç‰‡ï¼Œè«‹å”åŠ©åˆ¤æ–·å•é¡ŒåŠå»ºè­°è™•ç†æ–¹å¼ã€‚"
        response = self.model.generate_content(
            [prompt, image_bytes],
            generation_config={"temperature": 0.4}
        )
        return response.text
```

---

## src/knowledge_retriever.py

```python
class KnowledgeRetriever:
    def __init__(self):
        self.knowledge_base = {
            "ç”¢å“ä»‹ç´¹": {
                "keywords": ["ä»€éº¼", "åŠŸèƒ½", "ä»‹ç´¹"],
                "content": "æˆ‘å€‘çš„ç”¢å“å¯ä»¥..."
            },
            "åƒ¹æ ¼æ–¹æ¡ˆ": {
                "keywords": ["åƒ¹æ ¼", "è²»ç”¨", "å¤šå°‘éŒ¢"],
                "content": "åŸºæœ¬ç‰ˆå…è²»ï¼Œé€²éšç‰ˆæ¯æœˆ..."
            },
        }

    def retrieve(self, query):
        results = []
        for category, info in self.knowledge_base.items():
            if any(kw in query for kw in info["keywords"]):
                results.append(info["content"])
        if not results:
            results.append("æŠ±æ­‰ï¼Œæš«æ™‚æ²’æœ‰ç›¸é—œè³‡è¨Šã€‚")
        return results
```

---

# ğŸš€ ä¸‹ä¸€æ­¥å»ºè­°

* æŒ‰ç…§ä¸Šé¢ç¨‹å¼ç¢¼èª¿æ•´ webhook.pyï¼Œè£œé½Š `process_text_message`ï¼Œæ”¹ç”¨ `gemini-2.5-flash`
* æ¸¬è©¦æ–‡å­—ã€åœ–ç‰‡è¨Šæ¯ï¼Œæª¢æŸ¥ LINE webhook log å’Œä½ çš„ä¼ºæœå™¨ logï¼ˆVercelï¼‰
* é€æ­¥å„ªåŒ–çŸ¥è­˜åº«æˆ–ç”¨å‘é‡è³‡æ–™åº«ï¼ˆåƒ Pineconeã€Weaviateï¼‰
* åœ–ç‰‡åˆ†æåŠŸèƒ½å¯æ¥è‘—åŠ ä¸Šæ–‡å­—+åœ–ç‰‡çµåˆæç¤ºï¼Œè®“æ¨¡å‹æ›´æ‡‚ä¸Šä¸‹æ–‡
* éƒ¨ç½²æ™‚è¨˜å¾—è¨­å®šä¸‰å€‹ç’°å¢ƒè®Šæ•¸ï¼š`LINE_CHANNEL_SECRET`ã€`LINE_CHANNEL_ACCESS_TOKEN`ã€`GEMINI_API_KEY`

---

éœ€è¦æˆ‘å¹«ä½ å¯«æ›´å®Œæ•´çš„ READMEã€éƒ¨ç½²æ•™å­¸ã€mermaid æµç¨‹åœ–éƒ½å¯ä»¥è·Ÿæˆ‘èªªï¼
æƒ³è¦å“ªå€‹åŠŸèƒ½å„ªå…ˆä¹Ÿå‘Šè¨´æˆ‘ï½
